# Grocery Store Path Optimization
# Course: Optimization and Operations Research
# Authors: Hela Mouakhar, Hugo Youf

import itertools
import random
import matplotlib.pyplot as plt

# Supermarket layout
AISLES_X = [2, 4, 6, 8]
TOP_Y = 8
BOTTOM_Y = 0

ENTRANCE = (0, 0)
CHECKOUT = (10, 0)

ITEMS = {
    1: (2, 5),
    2: (4, 6),
    3: (6, 5),
    4: (8, 7),
    5: (6, 3)
}

# Distance
def aisle_distance(a, b):
    return abs(a[0] - b[0]) + abs(a[1] - b[1])

def total_distance(order, locations):
    return sum(
        aisle_distance(locations[order[i]], locations[order[i + 1]])
        for i in range(len(order) - 1)
    )

# Baseline
def baseline_solution(items, seed=0):
    random.seed(seed)
    shuffled = items.copy()
    random.shuffle(shuffled)
    return ['E'] + shuffled + ['C']

# 2-opt local search
def two_opt(order, locations):
    best = order
    improved = True

    while improved:
        improved = False
        for i in range(1, len(order) - 2):
            for j in range(i + 1, len(order) - 1):
                new_order = best[:i] + best[i:j][::-1] + best[j:]
                if total_distance(new_order, locations) < total_distance(best, locations):
                    best = new_order
                    improved = True
        order = best

    return best

# Exact solution
def exact_solution(locations, items):
    best_order = None
    best_dist = float("inf")

    for perm in itertools.permutations(items):
        order = ['E'] + list(perm) + ['C']
        dist = total_distance(order, locations)
        if dist < best_dist:
            best_dist = dist
            best_order = order

    return best_order, best_dist

# Build feasible path
def aisle_path(p1, p2):
    x1, y1 = p1
    x2, y2 = p2
    cross_y = BOTTOM_Y if y1 <= TOP_Y / 2 else TOP_Y
    return [(x1, y1), (x1, cross_y), (x2, cross_y), (x2, y2)]

def build_full_path(order, locations):
    path = []
    for i in range(len(order) - 1):
        segment = aisle_path(locations[order[i]], locations[order[i + 1]])
        path.extend(segment[:-1])
    path.append(locations[order[-1]])
    return path

# Plot
def plot_supermarket(path, title):
    plt.figure(figsize=(8, 6))

    for x in AISLES_X:
        plt.plot([x, x], [BOTTOM_Y, TOP_Y], color="black", linewidth=3)

    plt.plot([0, 10], [BOTTOM_Y, BOTTOM_Y], color="black", linewidth=3)
    plt.plot([0, 10], [TOP_Y, TOP_Y], color="black", linewidth=3)

    for i, (x, y) in ITEMS.items():
        plt.scatter(x, y, color="blue")
        plt.text(x + 0.1, y + 0.1, f"Item {i}")

    plt.scatter(*ENTRANCE, color="green", s=100)
    plt.text(ENTRANCE[0], ENTRANCE[1] - 0.4, "Entrance")

    plt.scatter(*CHECKOUT, color="red", s=100)
    plt.text(CHECKOUT[0], CHECKOUT[1] - 0.4, "Checkout")

    xs, ys = zip(*path)
    plt.plot(xs, ys, color="orange", linewidth=2)

    plt.title(title)
    plt.axis("equal")
    plt.grid(True)
    plt.show()

# Main
if __name__ == "__main__":
    locations = {"E": ENTRANCE, "C": CHECKOUT}
    for k, v in ITEMS.items():
        locations[k] = v

    items = list(ITEMS.keys())

    baseline_order = baseline_solution(items)
    baseline_dist = total_distance(baseline_order, locations)

    opt2_order = two_opt(baseline_order, locations)
    opt2_dist = total_distance(opt2_order, locations)

    optimal_order, optimal_dist = exact_solution(locations, items)

    print("Baseline distance:", baseline_dist)
    print("2-opt distance:", opt2_dist)
    print("Optimal distance:", optimal_dist)
    print(
        "Improvement vs baseline (%):",
        round(100 * (baseline_dist - opt2_dist) / baseline_dist, 2)
    )

    plot_supermarket(build_full_path(baseline_order, locations),
                     "Baseline Path")
    plot_supermarket(build_full_path(opt2_order, locations),
                     "2-opt Optimized Path")
    plot_supermarket(build_full_path(optimal_order, locations),
                     "Optimal Path (Exact)")
